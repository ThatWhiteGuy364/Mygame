<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="format-detection" content="telephone=no" />
  <!-- Cordova apps should include a Content Security Policy. Adjust as needed for plugins/endpoints. -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' data: gap: https://ssl.gstatic.com 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; media-src *" />
  <title>BattleTime!</title>
  <style>
    body{font-family:system-ui,"Segoe UI",Roboto,Helvetica,Arial,monospace;background:#333;padding:20px}
    #game-container{max-width:800px;margin:0 auto;background:#888;padding:18px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.08)}
    #output{background:#111;color:#aaa;padding:12px;height:360px;overflow:auto;white-space:pre-wrap;border-radius:6px}
    #controls,#setup{margin-top:12px}
    .btn{padding:8px 12px;margin:6px 6px 6px 0;cursor:pointer;border-radius:6px;border:1px solid #ddd;background:#999}
    .btn:disabled{opacity:.5;cursor:not-allowed}
    input[type=number],input[type=text],select{padding:6px;font-size:14px}
    .statline{font-size:13px;color:#666;margin-top:6px}
    /* Make buttons a bit larger for touch devices */
    .btn{min-height:40px;min-width:88px}
  </style>

  <!-- Cordova runtime script - provided by the platform at runtime -->
  <script src="cordova.js"></script>
</head>
<body>
  <div id="game-container">
    <h1>BattleTime! (JS port of main.py)</h1>
    <div id="output">Welcome User.</div>

    <div id="setup">
      <div>
        <label>Name: <input id="name-input" maxlength="16" value="Player" /></label>
      </div>

      <div style="margin-top:8px">
        <label>Class:
          <select id="class-select">
            <option value="Fighter">Fighter</option>
            <option value="Mage">Mage</option>
          </select>
        </label>
      </div>

      <div style="margin-top:8px">
        <label>Difficulty (1 = Easy, 5 = Hard):
          <input id="diff-input" type="number" min="1" max="5" value="3" style="width:60px" />
        </label>
      </div>

      <div style="margin-top:10px">
        <button id="start-btn" class="btn">Start Game</button>
      </div>

      <div class="statline">Tips: When prompted, click move buttons to act. Survive as many rounds as you can.</div>
    </div>

    <div id="controls" style="display:none;margin-top:12px"></div>
  </div>

  <script>
    // This script is the original game logic adapted to wait for Cordova's deviceready
    // It also falls back to running in a browser when cordova.js is not present.

    (function () {
      // Cache DOM elements
      const out = document.getElementById("output"),
            setup = document.getElementById("setup"),
            controls = document.getElementById("controls"),
            startBtn = document.getElementById("start-btn");

      function log(t = "") {
        out.innerText += t + "\n";
        out.scrollTop = out.scrollHeight;
      }

      function sleep(t) {
        return new Promise((res => setTimeout(res, t)));
      }

      function randint(t, e) {
        t = Math.ceil(t);
        e = Math.floor(e);
        return Math.floor(Math.random() * (e - t + 1)) + t;
      }

      class Character {
        constructor(t, e, n, a, s, o, r, i) {
          this.lv = r;
          this.exp = i || 0;
          this.name = "Unit";
          this.statuses = [];
          if ("Fighter" === o) {
            this.atk = Math.ceil(t * (r / 4 * 5));
            this.defn = Math.ceil(e + 3 * r);
            this.spd = Math.ceil(Math.max(n + r, n * (r / 2)));
            this.hp = Math.ceil(1.5 * a + 2 * r);
            this.mp = Math.ceil(s + 7.5 * r);
          } else {
            this.atk = Math.ceil(t * (r / 4 * 4));
            this.defn = Math.ceil(e + 2 * r);
            this.spd = Math.ceil(n + 1.5 * r);
            this.hp = Math.ceil(1.7 * a + r);
            this.mp = Math.ceil(s + 15 * r);
          }
          this.max_hp = this.hp;
          this.max_mp = this.mp;
          this.moves = "Fighter" === o ? [
            { name: "Slash", dmg: t => randint(t.atk - t.lv, t.atk + t.lv), cost: 0, type: "atk" },
            { name: "Mend", dmg: t => -Math.ceil(t.max_hp / 4), cost: 15, type: "heal" },
            { name: "Wind Step", dmg: t => Math.floor(t.atk + 2 * t.spd), cost: 15, type: "atk" },
            { name: "Iron Will", effect: { name: "Shield", dur: 3, pwr: Math.floor(this.defn / 4), type: "buff" }, cost: 10, type: "status" },
            { name: "Thousand Cuts", dmg: t => randint(t.atk, 3 * t.atk), cost: t => Math.floor(t.mp / 2), type: "atk" }
          ] : [
            { name: "Fireball", dmg: t => randint(t.atk, Math.floor(1.5 * t.atk)), effect: { name: "Burn", dur: 3, pwr: t => t.lv, type: "dot" }, cost: 10, type: "atk" },
            { name: "Arcane Bolt", dmg: t => Math.floor(2 * t.atk), cost: 15, type: "atk" },
            { name: "Freeze", dmg: t => t.atk, effect: { name: "Stun", dur: 1, pwr: 0, type: "stun" }, cost: 25, type: "atk" },
            { name: "Mana Drain", dmg: t => t.atk, effect: { name: "Focus", dur: 2, pwr: 10, type: "mp_regen" }, cost: 0, type: "atk" },
            { name: "Meteor", dmg: t => randint(3 * t.atk, 4 * t.atk), cost: t => Math.floor(t.max_mp / 2), type: "atk" }
          ];
        }

        applyStatuses() {
          for (const st of [...this.statuses]) {
            if ("dot" === st.type) {
              const dmg = typeof st.pwr === "function" ? st.pwr(this) : st.pwr;
              this.hp = Math.max(0, this.hp - dmg);
              log(`[${this.name}] ${st.name} dealt ${dmg} damage!`);
            } else if ("mp_regen" === st.type) {
              const amt = typeof st.pwr === "function" ? st.pwr(this) : st.pwr;
              this.mp = Math.min(this.max_mp, this.mp + amt);
              log(`[${this.name}] ${st.name} restored ${amt} MP!`);
            }
            st.dur -= 1;
            if (st.dur <= 0) {
              log(`[${this.name}] ${st.name} effect ended.`);
              const idx = this.statuses.indexOf(st);
              if (idx >= 0) this.statuses.splice(idx, 1);
            }
          }
        }

        takeDam(dmg) {
          const rand = randint(Math.min(this.spd, 100), Math.max(this.spd, 100));
          if (this.spd / 2 > rand) return `${this.name} Dodged!`;
          const buffSum = this.statuses.filter(s => ("buff" === s.type)).reduce((acc, s) => acc + (typeof s.pwr === "function" ? s.pwr(this) : s.pwr), 0);
          const actual = Math.max(1, dmg - Math.floor(this.defn / 2) - buffSum);
          this.hp = Math.max(0, this.hp - actual);
          return `${this.name} took ${actual} damage!`;
        }
      }

      function executeTurn(actor, target, move) {
        const cost = typeof move.cost === "function" ? move.cost(actor) : move.cost || 0;
        actor.mp -= cost;
        log(`\n${actor.name} used ${move.name}!`);
        if (move.type === "heal") {
          const amt = Math.abs(typeof move.dmg === "function" ? move.dmg(actor) : 0);
          actor.hp = Math.min(actor.max_hp, actor.hp + amt);
          log(`${actor.name} healed for ${amt} HP!`);
        } else if (move.type === "status") {
          const ef = move.effect;
          const copy = Object.assign({}, ef);
          actor.statuses.push(copy);
          log(`${ef.name} applied to ${actor.name}!`);
        } else {
          const dmg = typeof move.dmg === "function" ? move.dmg(actor) : move.dmg || 0;
          log(target.takeDam(dmg));
          if (move.effect) {
            const ef = move.effect;
            const copy = Object.assign({}, ef);
            target.statuses.push(copy);
            log(`${ef.name} applied to ${target.name}!`);
          }
        }
      }

      class Enemy extends Character {
        constructor(...args) {
          super(...args);
          this.name = `Enemy Lv.${this.lv}`;
        }
        attack() {
          const available = this.moves.filter(m => (typeof m.cost === "function" ? m.cost(this) : m.cost || 0) <= this.mp);
          if (available.length === 0) return this.moves[0];
          const scores = available.map(m => {
            const cost = typeof m.cost === "function" ? m.cost(this) : m.cost || 0;
            const dmg = Math.abs(typeof m.dmg === "function" ? m.dmg(this) : 0);
            return (dmg + 1) / (cost + 1);
          });
          const total = scores.reduce((a, b) => a + b, 0);
          let pick = Math.random() * total;
          for (let i = 0; i < available.length; i++) {
            pick -= scores[i];
            if (pick <= 0) return available[i];
          }
          return available[available.length - 1];
        }
      }

      class Player extends Character {
        constructor(...args) {
          super(...args);
          this.name = "You";
        }

        presentMoves() {
          controls.innerHTML = "";
          const info = document.createElement("div");
          info.innerText = `--- ${this.name} | HP: ${this.hp}/${this.max_hp} | MP: ${this.mp}/${this.max_mp} ---`;
          controls.appendChild(info);
          return new Promise((resolve => {
            this.moves.forEach((m, idx) => {
              const cost = typeof m.cost === "function" ? m.cost(this) : m.cost || 0;
              const btn = document.createElement("button");
              btn.className = "btn";
              btn.innerText = `${m.name} (MP:${cost})`;
              if (this.mp < cost) btn.disabled = true;
              btn.onclick = () => {
                controls.innerHTML = "";
                resolve(m);
              };
              controls.appendChild(btn);
            });
          }));
        }
      }

      function generateStats(level, cls = "Fighter") {
        return [randint(20, 40), randint(10, 20), randint(10, 40), randint(75, 100), randint(10, 60), cls, level, 0];
      }

      let playerInstance = null, roundCount = 1;
      const SLEEPER = 800;

      async function startGameFlow(name, cls, diff) {
        log("\nStarting game...\n");
        const diffVal = parseInt(diff, 10);
        const playerStats = generateStats(Number.isInteger(diffVal) && diffVal >= 1 && diffVal <= 5 ? 6 - diffVal : 3, cls);
        playerInstance = new Player(...playerStats);
        playerInstance.name = name;
        log(`Name: ${playerInstance.name} | Class: ${cls} | Lv: ${playerInstance.lv}`);
        log(`Starting HP: ${playerInstance.hp} | MP: ${playerInstance.mp}\n`);
        await sleep(1000);

        while (playerInstance.hp > 0) {
          const enemyClass = Math.random() < 0.5 ? "Fighter" : "Mage";
          const enemyStats = generateStats(roundCount, enemyClass);
          const enemy = new Enemy(...enemyStats);
          log(`\n*** ROUND ${roundCount} ***\nAn ${enemy.name} (Lv.${enemy.lv}) appeared!`);

          let turn = playerInstance.spd >= enemy.spd ? "player" : "enemy";

          while (playerInstance.hp > 0 && enemy.hp > 0) {
            const actor = turn === "player" ? playerInstance : enemy;

            actor.applyStatuses();
            if (playerInstance.hp <= 0 || enemy.hp <= 0) break;

            if (actor.statuses.some(s => s.type === "stun")) {
              log(`${actor.name} is stunned and skips their turn!`);
            } else if (turn === "player") {
              const move = await playerInstance.presentMoves();
              executeTurn(playerInstance, enemy, move);
              await sleep(500);
              log(`Enemy HP remaining: ${enemy.hp}\n`);
              if (enemy.hp <= 0) {
                log("--- VICTORY! ---");
                const recoveredHP = randint(10 + roundCount, 20 + roundCount);
                const recoveredMP = randint(10 + roundCount, 20 + roundCount);
                playerInstance.hp = Math.min(playerInstance.max_hp, playerInstance.hp + recoveredHP);
                playerInstance.mp = Math.min(playerInstance.max_mp, playerInstance.mp + recoveredMP);
                log(`Recovered ${recoveredHP} HP and ${recoveredMP} MP.`);
                roundCount += 1;
                await sleep(800);
                break;
              }
            } else {
              const move = enemy.attack();
              executeTurn(enemy, playerInstance, move);
              await sleep(500);
              log(`Your HP remaining: ${playerInstance.hp}\n`);
              if (playerInstance.hp <= 0) {
                log("\n---- GAME OVER ----");
                log(`Survived ${roundCount} rounds.`);
                controls.innerHTML = "";
                return;
              }
            }

            turn = turn === "player" ? "enemy" : "player";
            await sleep(800);
          }

          if (!(playerInstance.hp > 0)) {
            controls.innerHTML = "";
            return;
          }
          await sleep(800);
        }
      }

      // Init function to wire up UI after device is ready (or immediately in browser)
      function initApp() {
        // Avoid double-init
        if (initApp._initialized) return;
        initApp._initialized = true;

        startBtn.addEventListener("click", async () => {
          const t = document.getElementById("name-input").value.trim() || "Player",
                e = document.getElementById("class-select").value,
                n = document.getElementById("diff-input").value;
          if (t.length > 16) {
            alert("Name max 16 characters.");
            return;
          }
          setup.style.display = "none";
          controls.style.display = "block";
          log(`\nWelcome ${t}.\nGame starting...`);
          await startGameFlow(t, e, n);
        });

        // Informational initial logs
        log("\nInput your name. This may be the last you do so. Choose wisely:");
        log("(Use the form below, then click Start Game.)");

        // If running on a device with a splashscreen plugin, hide it if available
        if (navigator && navigator.splashscreen && typeof navigator.splashscreen.hide === "function") {
          try { navigator.splashscreen.hide(); } catch (e) { /* ignore */ }
        }
      }

      // Wait for Cordova deviceready. If Cordova isn't available (browser), fall back to DOMContentLoaded.
      document.addEventListener('deviceready', function () {
        log("[Cordova] deviceready event received.");
        initApp();
      }, false);

      // For browser testing when cordova.js isn't present
      if (!window.cordova) {
        // DOMContentLoaded ensures elements are present
        document.addEventListener('DOMContentLoaded', function () {
          log("[Browser] DOMContentLoaded - running in browser fallback.");
          initApp();
        });
      }
    })();
  </script>
</body>
</html>